{"version":3,"sources":["../src/datasource.js"],"names":["_","TableModel","ThrukDatasource","instanceSettings","$q","backendSrv","templateSrv","q","url","withCredentials","basicAuth","requestOptions","_requestOptions","method","datasourceRequest","then","response","status","message","title","options","query","parseQuery","annotation","table","columns","path","where","Math","floor","range","from","toDate","getTime","to","encodeURIComponent","map","result","data","d","i","replace","text","Object","values","join","value","x","targets","length","target","split","forEach","addColumn","col","condition","keys","row","push","rows","headers","Authorization","tmp","match","Error"],"mappings":"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","file":"datasource.js","sourcesContent":["import _ from \"lodash\";\nimport TableModel from 'app/core/table_model';\n\nexport class ThrukDatasource {\n\n  constructor(instanceSettings, $q, backendSrv, templateSrv) {\n    this.q = $q;\n    this.backendSrv = backendSrv;\n    this.templateSrv = templateSrv;\n    this.url = instanceSettings.url;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.basicAuth = instanceSettings.basicAuth;\n  }\n\n  testDatasource() {\n    var requestOptions = this._requestOptions({\n      url: this.url + '/r/v1/',\n      method: 'GET'\n    });\n    return this.backendSrv.datasourceRequest(requestOptions)\n      .then(response => {\n        if (response.status === 200) {\n          return { status: \"success\", message: \"Data source is working\", title: \"Success\" };\n        }\n      });\n  }\n\n  annotationQuery(options) {\n    var query = this.parseQuery(options.annotation.query);\n    if(query.table == 'logs' || query.table == '/logs') {\n      query.columns = \"time,message,type\";\n    }\n    var path = query.table+\"?columns=\"+query.columns;\n    if(query.where) {\n      query.where += \" AND \";\n    }\n    query.where += \" time > \"+Math.floor(options.range.from.toDate().getTime()/1000);\n    query.where += \" AND time < \"+Math.floor(options.range.to.toDate().getTime()/1000);\n    if(query.where) {\n      path += '&q='+encodeURIComponent(query.where)\n    }\n\n    var requestOptions = this._requestOptions({\n      url: this.url + '/r/v1/'+path,\n      method: 'GET'\n    });\n    // TODO: catch wrong column or other rest api errors\n    return this.backendSrv.datasourceRequest(requestOptions)\n      .then(result => {\n        return _.map(result.data, (d, i) => {\n          return {\n            \"annotation\": options.annotation,\n            \"title\": d['type'],\n            \"time\": d['time']*1000,\n            \"text\": d['message'].replace(/^\\[\\d+\\]\\s+/, '').replace(/^[^:]+:\\s+/, ''),\n            \"tags\": d['type'],\n          };\n        });\n      });\n  }\n\n  metricFindQuery(options) {\n    var query = this.parseQuery(options);\n    var path = query.table+\"?columns=\"+query.columns;\n    if(query.where) {\n      path += '&q='+encodeURIComponent(query.where)\n    }\n    var requestOptions = this._requestOptions({\n      url: this.url + '/r/v1/'+path,\n      method: 'GET',\n    });\n    // TODO: catch wrong column or other rest api errors\n    return this.backendSrv.datasourceRequest(requestOptions)\n      .then(result => {\n        return _.map(result.data, (d, i) => {\n          return { text: Object.values(d).join(';'), value: Object.values(d).join(';') };\n        });\n      });\n  }\n\n  query(options) {\n    // we can only handle a single query right now\n    for(var x=0; x<options.targets.length; x++) {\n      var table = new TableModel();\n      var target = options.targets[x];\n      var path = target.table\n      if(target.columns && target.columns != '*') {\n        path += \"?columns=\"+target.columns;\n        target.columns.split(/\\s*,\\s*/).forEach(col => {\n          table.addColumn({ text: col });\n        });\n      }\n      if(target.condition) {\n        path += '&q='+encodeURIComponent(target.condition)\n      }\n      var requestOptions = this._requestOptions({\n        url: this.url + '/r/v1/'+path,\n        method: 'GET',\n      });\n      return this.backendSrv.datasourceRequest(requestOptions).then(function(result) {\n        // extract columns from first result row unless specified\n        if(!(target.columns && target.columns != '*') && result.data[0]) {\n          Object.keys(result.data[0]).forEach(col => {\n            table.addColumn({ text: col });\n          });\n        }\n        // add data rows\n        _.map(result.data, (d, i) => {\n          var row = [];\n          table.columns.forEach(col => {\n            row.push(d[col.text]);\n          });\n          table.rows.push(row);\n        });\n        return({\n          data: [\n            table\n          ]\n        });\n      });\n    }\n  }\n\n  _requestOptions(options) {\n    options = options || {};\n    options.headers = options.headers || {};\n    if(this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n    if(this.basicAuth) {\n      options.headers.Authorization = this.basicAuth;\n    }\n    options.headers['Content-Type'] = 'application/json';\n    return(options);\n  }\n\n  parseQuery(query) {\n    query = this.templateSrv.replace(query, null, 'regex')\n    // TODO: support sort and limit\n    var tmp = query.match(/^\\s*SELECT\\s+([\\w_,\\ ]+)\\s+FROM\\s+([\\w_\\/]+)(|\\s+WHERE\\s+(.*))$/i);\n    if(!tmp) {\n      throw new Error(\"query syntax error, expecting: SELECT <column>[,<columns>] FROM <rest url> [WHERE <filter conditions>]\");\n    }\n    return({\n      columns: tmp[1].replace(/\\s+/g, ''),\n      table:   tmp[2],\n      where:   tmp[4],\n    });\n  }\n}\n"]}